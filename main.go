package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"os"
	"regexp"

	"github.com/sirupsen/logrus"
	easy "github.com/t-tomalak/logrus-easy-formatter"
)

var MaxPercentThreshold uint
var AvgPercentThreshold uint

func main() {
	logger := logrus.New()
	logger.SetLevel(logrus.InfoLevel)
	myformatter := &easy.Formatter{}
	myformatter.TimestampFormat = "2006-01-02 15:04:05.000"
	myformatter.LogFormat = "[%lvl%][%time%] %msg%\n"
	logger.SetFormatter(myformatter)
	logger.SetOutput(os.Stdout)
	logger.Info("This tool conducts simple analysis of a Cx1e2e JSON report and generates a cx1e2e-history.json datafile. The cx1e2e-history.json file is also used as input to identify deviations in test duration.")

	ReportFile := flag.String("report", "cx1e2e_result.json", "Cx1e2e JSON report file")
	HistoryFile := flag.String("history", "cx1e2e-history.json", "Cx1e2e-tracker history file")
	MaxPercent := flag.Uint("max-pcf", 15, "Output a warning when test duration exceeds historical maximum by this percentage")
	AvgPercent := flag.Uint("avg-pcf", 15, "Output a warning when test duration exceeds historical average by this percentage")

	flag.Parse()

	MaxPercentThreshold = *MaxPercent
	AvgPercentThreshold = *AvgPercent

	if *ReportFile == "" {
		logger.Fatalf("Must provide a report parameter - this should be the JSON report generated by Cx1e2e")
	}
	if *HistoryFile == "" {
		logger.Fatalf("Must provide a history parameter - this should be the JSON history datafile generated by Cx1e2e-tracker")
	}

	var report Report

	if reportdata, err := os.ReadFile(*ReportFile); err != nil {
		logger.Fatalf("Failed to read report file %v: %s", *ReportFile, err)
	} else if err := json.Unmarshal(reportdata, &report); err != nil {
		logger.Fatalf("Failed to parse report file %v: %s", *ReportFile, err)
	} else {
		logger.Infof("Loaded cx1e2e report from file %v", *ReportFile)
	}

	var history History

	if historydata, err := os.ReadFile(*HistoryFile); err != nil {
		logger.Errorf("Failed to read history file %v: %s", *HistoryFile, err)
		logger.Infof("A new history file %v will be generated", *HistoryFile)
		history = History{
			Pass: map[string]HistoryMetric{},
		}
	} else if err := json.Unmarshal(historydata, &history); err != nil {
		logger.Fatalf("Failed to parse history file %v: %s", *HistoryFile, err)
	} else {
		logger.Infof("Loaded cx1e2e history from file %v", *HistoryFile)
	}

	var suffix_re *regexp.Regexp
	if report.Settings.E2ESuffix != "" {
		suffix_re = regexp.MustCompile(fmt.Sprintf("%v$", report.Settings.E2ESuffix))
	}

	for _, test := range report.Details {
		history.AddResult(suffix_re, test, logger)
	}

	if historydata, err := json.Marshal(history); err != nil {
		logger.Fatalf("Failed to marshal history: %s", err)
	} else if err := os.WriteFile(*HistoryFile, historydata, 0644); err != nil {
		logger.Fatalf("Failed to write history file %v: %s", *HistoryFile, err)
	} else {
		logger.Infof("Wrote cx1e2e history to file %v", *HistoryFile)
	}
}

func (h *History) AddResult(re *regexp.Regexp, result ReportTestDetails, logger *logrus.Logger) {
	if result.Result != "PASS" {
		return
	}

	var key string
	if re == nil {
		key = fmt.Sprintf("%v - %v", result.Source, result.Test)
	} else {
		testName := re.ReplaceAllString(result.Test, "")
		key = fmt.Sprintf("%v - %v", result.Source, testName)
	}

	if hist, ok := h.Pass[key]; ok {
		m, a := hist.Add(result)
		if m > MaxPercentThreshold {
			logger.Warnf("Passing test %v duration %f exceeded historical max by %d%%", key, result.Duration, m)
		}
		if a > AvgPercentThreshold {
			logger.Warnf("Passing test %v duration %f exceeded historical average by %d%%", key, result.Duration, a)
		}
		h.Pass[key] = hist
	} else {
		h.Pass[key] = NewMetric(result)
	}

}

func NewMetric(result ReportTestDetails) HistoryMetric {
	return HistoryMetric{
		Min:     result.Duration,
		Max:     result.Duration,
		Average: result.Duration,
		Count:   1,
	}
}

func (m *HistoryMetric) Add(result ReportTestDetails) (uint, uint) {
	max_pct := uint(100.0 * result.Duration / m.Max)
	if max_pct < 100 {
		max_pct = 100
	}
	max_pct -= 100

	avg_pct := uint(100.0 * result.Duration / m.Average)
	if avg_pct < 100 {
		avg_pct = 100
	}
	avg_pct -= 100

	var total float64 = float64(m.Count) * m.Average
	m.Count++
	m.Average = (total + result.Duration) / float64(m.Count)
	if m.Min > result.Duration {
		m.Min = result.Duration
	}
	if m.Max < result.Duration {
		m.Max = result.Duration
	}

	return max_pct, avg_pct
}

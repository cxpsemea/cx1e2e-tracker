package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"math"
	"os"
	"regexp"
	"strings"
	"text/tabwriter"

	"github.com/sirupsen/logrus"
	easy "github.com/t-tomalak/logrus-easy-formatter"
)

var MaxPercentThreshold uint
var AvgPercentThreshold uint
var CmpPercentThreshold uint

func main() {
	logger := logrus.New()
	logger.SetLevel(logrus.InfoLevel)
	myformatter := &easy.Formatter{}
	myformatter.TimestampFormat = "2006-01-02 15:04:05.000"
	myformatter.LogFormat = "[%lvl%][%time%] %msg%\n"
	logger.SetFormatter(myformatter)
	logger.SetOutput(os.Stdout)
	logger.Info("This tool conducts simple analysis of a Cx1e2e JSON report and generates a cx1e2e-history.json datafile. The cx1e2e-history.json file is also used as input to identify deviations in test duration.")

	ReportFile := flag.String("report", "cx1e2e_result.json", "Cx1e2e JSON report file generated by cx1e2e")
	CompareFile := flag.String("compare", "cx1e2e_result2.json", "Cx1e2e JSON report file generated by cx1e2e to compare against")
	HistoryFile := flag.String("history", "cx1e2e-history.json", "Cx1e2e-tracker history file generated by this program")
	MaxPercent := flag.Uint("max-pct", 15, "Output a warning when test duration exceeds historical maximum by this percentage")
	AvgPercent := flag.Uint("avg-pct", 15, "Output a warning when test duration exceeds historical average by this percentage")
	CmpPercent := flag.Uint("cmp-pct", 15, "When comparing two reports, hide tests that have durations that differ by less than this percentage")

	flag.Parse()

	MaxPercentThreshold = *MaxPercent
	AvgPercentThreshold = *AvgPercent
	CmpPercentThreshold = *CmpPercent

	if *ReportFile == "" {
		logger.Fatalf("Must provide a report parameter - this should be the JSON report generated by Cx1e2e")
	}
	if *HistoryFile == "" && *CompareFile == "" {
		logger.Fatalf("Must provide a history or compare parameter")
	}

	if *CompareFile != "" {
		CompareReports(*ReportFile, *CompareFile, logger)
	} else {
		CompareHistory(*ReportFile, *HistoryFile, logger)
	}
}

func (c comparisonEntry) Show() bool {
	return c.Result1 != c.Result2 ||
		c.Duration1 > 0 && 100.0*math.Abs((c.Duration2-c.Duration1)/c.Duration1) > float64(CmpPercentThreshold)
}

func (c comparisonEntry) String() string {
	parts := strings.Split(c.TestName, ":")
	if c.Result1 == c.Result2 {
		if c.Duration1 > 0 {
			return fmt.Sprintf("%v\t%d\t%v (%.2fs)\t%v (%.2fs)\t%.2f%%", parts[0], c.ID, c.Result1[:4], c.Duration1, c.Result2[:4], c.Duration2, 100.0*c.Duration2/c.Duration1)
		} else {
			return fmt.Sprintf("%v\t%d\t%v (%.2fs)\t%v (%.2fs)\t-", parts[0], c.ID, c.Result1[:4], c.Duration1, c.Result2[:4], c.Duration2)
		}
	} else {
		return fmt.Sprintf("%v\t%d\t%v (%.2fs)\t%v (%.2fs)\t-", parts[0], c.ID, c.Result1[:4], c.Duration1, c.Result2[:4], c.Duration2)
	}
}

func CompareReports(reportFile1, reportFile2 string, logger *logrus.Logger) {
	var report1, report2 Report

	if reportdata, err := os.ReadFile(reportFile1); err != nil {
		logger.Fatalf("Failed to read report file %v: %s", reportFile1, err)
	} else if err := json.Unmarshal(reportdata, &report1); err != nil {
		logger.Fatalf("Failed to parse report file %v: %s", reportFile1, err)
	} else {
		logger.Infof("Loaded cx1e2e report from file %v", reportFile1)
	}

	if reportdata, err := os.ReadFile(reportFile2); err != nil {
		logger.Fatalf("Failed to read report file %v: %s", reportFile2, err)
	} else if err := json.Unmarshal(reportdata, &report2); err != nil {
		logger.Fatalf("Failed to parse report file %v: %s", reportFile2, err)
	} else {
		logger.Infof("Loaded cx1e2e report from file %v", reportFile2)
	}

	var suffix_re1, suffix_re2 *regexp.Regexp
	if report1.Settings.E2ESuffix != "" {
		suffix_re1 = regexp.MustCompile(fmt.Sprintf("%v$", report1.Settings.E2ESuffix))
	}
	if report2.Settings.E2ESuffix != "" {
		suffix_re2 = regexp.MustCompile(fmt.Sprintf("%v$", report2.Settings.E2ESuffix))
	}

	var comparison []comparisonEntry

	for _, result1 := range report1.Details {
		var key1 string
		if suffix_re1 == nil {
			key1 = fmt.Sprintf("%v - %v", result1.Source, result1.Test)
		} else {
			testName := suffix_re1.ReplaceAllString(result1.Test, "")
			key1 = fmt.Sprintf("%v - %v", result1.Source, testName)
		}

		logger.Infof("Test1: %v %v in %.2f seconds", key1, result1.Result, result1.Duration)

		for _, result2 := range report2.Details {
			var key2 string
			if suffix_re2 == nil {
				key2 = fmt.Sprintf("%v - %v", result2.Source, result2.Test)
			} else {
				testName := suffix_re2.ReplaceAllString(result2.Test, "")
				key2 = fmt.Sprintf("%v - %v", result2.Source, testName)
			}

			if key1 == key2 {
				logger.Infof("Test2: %v %v in %.2f seconds", key2, result2.Result, result2.Duration)
				comparison = append(comparison, comparisonEntry{
					TestName:  key1,
					Result1:   result1.Result,
					Result2:   result2.Result,
					Duration1: result1.Duration,
					Duration2: result2.Duration,
					ID:        result1.ID,
				})
			}
		}
	}

	w := tabwriter.NewWriter(os.Stdout, 1, 1, 1, ' ', 0)
	fmt.Fprintf(w, "Test\t%v\t%v\tRatio\n", reportFile1, reportFile2)
	for _, c := range comparison {
		if c.Show() {
			fmt.Fprintln(w, c.String())
		}
	}
	w.Flush()

}

func CompareHistory(reportFile, historyFile string, logger *logrus.Logger) {
	var report Report

	if reportdata, err := os.ReadFile(reportFile); err != nil {
		logger.Fatalf("Failed to read report file %v: %s", reportFile, err)
	} else if err := json.Unmarshal(reportdata, &report); err != nil {
		logger.Fatalf("Failed to parse report file %v: %s", reportFile, err)
	} else {
		logger.Infof("Loaded cx1e2e report from file %v", reportFile)
	}

	var history History

	if historydata, err := os.ReadFile(historyFile); err != nil {
		logger.Errorf("Failed to read history file %v: %s", historyFile, err)
		logger.Infof("A new history file %v will be generated", historyFile)
		history = History{
			Pass: map[string]HistoryMetric{},
		}
	} else if err := json.Unmarshal(historydata, &history); err != nil {
		logger.Fatalf("Failed to parse history file %v: %s", historyFile, err)
	} else {
		logger.Infof("Loaded cx1e2e history from file %v", historyFile)
	}

	var suffix_re *regexp.Regexp
	if report.Settings.E2ESuffix != "" {
		suffix_re = regexp.MustCompile(fmt.Sprintf("%v$", report.Settings.E2ESuffix))
	}

	for _, test := range report.Details {
		history.AddResult(suffix_re, test, logger)
	}

	if historydata, err := json.Marshal(history); err != nil {
		logger.Fatalf("Failed to marshal history: %s", err)
	} else if err := os.WriteFile(historyFile, historydata, 0644); err != nil {
		logger.Fatalf("Failed to write history file %v: %s", historyFile, err)
	} else {
		logger.Infof("Wrote cx1e2e history to file %v", historyFile)
	}
}

func (h *History) AddResult(re *regexp.Regexp, result ReportTestDetails, logger *logrus.Logger) {
	if result.Result != "PASS" {
		return
	}

	var key string
	if re == nil {
		key = fmt.Sprintf("%v - %v", result.Source, result.Test)
	} else {
		testName := re.ReplaceAllString(result.Test, "")
		key = fmt.Sprintf("%v - %v", result.Source, testName)
	}

	if hist, ok := h.Pass[key]; ok {
		m, a := hist.Add(result)
		if m > MaxPercentThreshold {
			logger.Warnf("Passing test %v duration %f exceeded historical max by %d%%", key, result.Duration, m)
		}
		if a > AvgPercentThreshold {
			logger.Warnf("Passing test %v duration %f exceeded historical average by %d%%", key, result.Duration, a)
		}
		h.Pass[key] = hist
	} else {
		h.Pass[key] = NewMetric(result)
	}

}

func NewMetric(result ReportTestDetails) HistoryMetric {
	return HistoryMetric{
		Min:     result.Duration,
		Max:     result.Duration,
		Average: result.Duration,
		Count:   1,
	}
}

func (m *HistoryMetric) Add(result ReportTestDetails) (uint, uint) {
	max_pct := uint(100.0 * result.Duration / m.Max)
	if max_pct < 100 {
		max_pct = 100
	}
	max_pct -= 100

	avg_pct := uint(100.0 * result.Duration / m.Average)
	if avg_pct < 100 {
		avg_pct = 100
	}
	avg_pct -= 100

	var total float64 = float64(m.Count) * m.Average
	m.Count++
	m.Average = (total + result.Duration) / float64(m.Count)
	if m.Min > result.Duration {
		m.Min = result.Duration
	}
	if m.Max < result.Duration {
		m.Max = result.Duration
	}

	return max_pct, avg_pct
}
